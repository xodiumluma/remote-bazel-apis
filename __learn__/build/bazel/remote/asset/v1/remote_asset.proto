syntax = "proto3";

package build.bazel.remote.asset.v1;

import "build/bazel/remote/execution/v2/remote_execution.proto";
import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/rpc/status.proto";

option csharp_namespace = "Build.Bazel.Remote.Asset.v1";
option go_package = "github.com/bazelbuild/remote-apis/build/bazel/remote/asset/v1";
option java_multiple_files = true;
option java_outer_classname = "RemoteAssetProto";
option java_package = "build.bazel.remote.asset.v1";
option obj_class_prefix = "RA";

// Remote Asset API maps from URL + Qualifiers to Digests
// Same content can be referred to from several URIs, e.g. same tarball is available from multiple mirrors and accessible via multiple URLs
// The URLs, when used, should refer to actual content - Fetch service implementations might want to retrieve the content directly
// E.g. git repo's active branch (HEAD) can be referred to as: 
//    uri: https://github.com/bazelbuild/remote-apis.git
// URNs can be used to refer to specific contnet, such as using a uuid namespace id:
//    urn:uuid:<id>
// This is applicable to content that has been uploaded via the Push implementation
// The URN contains an agreed-upon key but doesn't mean anything else
//
// Service implementations can mix and match URLs and URNs, or just specify URLs, or only URNs for Push-uploaded content - no hard and fast rule

// In order to ensure that content is unique or for subselecting content with a common URI, qualifiers are used
// Examples include a specific commit/branch wrt URIs that refer to a specific repo, and a URI that refers to a particular folder of a repo or a compressed payload
// Qualifiers are also used to specify a checksum for content integrity

// We use `resource_type` when it is not clear what is inferred from the URL and/or the qualifiers

// There is no ordering to qualifiers
message Qualifier {
  // the key, e.g. "resource_type"
  // Just make sure that the name is crystal clear, even though there's no effort made to distinguish "standard" and "nonstandard" qualfiliers
  // https://tools.ietf.org/rfc6648 
  string name = 1;
  string value = 2; // the name will explain the value - so choose the name carefully
}

// Fetch service retrieves or resolves payloads that are referenced by URI and Qualifiers
// A Digest for the content in [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage] is returned
//
// Like any service in the Remote Execution API, an error with [RetryInfo][google.rpc.RetryInfo] metadata may be returned - this sheds light on when the client should reattempt a Fetch call
// Clients need to respect the instructions in the metadata
service Fetch {
  // Retrieve/resolve referenced payloads - expose them to the caller/other consumers in [ContentAddressableStorage][build.bazel.remote.execution.v2.ContentAddressableStorage]
  //
  // Servers *MAY* retrieve payloads that are not cached, based on supported URL structures
  // Servers *SHOULD* make sure that the referenced payloads are available in the CAS when receiving the response
  // If this feature is available, they should also make sure that they can be accessed within a reasonable time window
  // If required, this time window should be widened
  // If a client obtains a reference to unavailable payloads, it *MAY* resend the request with `oldest_content_accepted` set to a newer timestamp than the original try - to trigger a second retrieval
  // Servers *CAN* cache retrieved payloads and reuse it for later retrievals, based on `oldest_content_accepted`
  // Servers *CAN* accept the related [Push][build.bazel.remote.asset.v1.Push] API and enable content to be directly upserted for subsequent retrievals
}